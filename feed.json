{
  "version": "https://jsonfeed.org/version/1",
  "title": "Exceptionless",
  "home_page_url": "https://exceptionless.github.io/website/",
  "feed_url": "https://exceptionless.github.io/website/feed.json",
  "description": "Real-time exception reporting for ASP.NET, Web API, WebForms, WPF, Console, and MVC applications. Includes event organization, notifications, and more.",
  "author": {
    "name": "Exceptionless Team"
  },
  "items": [
    {
      "id": "https://exceptionless.github.io/website/news/2021/2021-09-09-announcing-the-new-exceptionless-javascript-client/",
      "url": "https://exceptionless.github.io/website/news/2021/2021-09-09-announcing-the-new-exceptionless-javascript-client/",
      "title": "Announcing The New Exceptionless JavaScript Client",
      "content_html": "<p><img src=\"./js_client_2_0_announcement.png\" alt=\"Exceptionless announcement\"></p>\n<p>We have had a JavaScript client for several years, but it was quickly becoming out of date. To help address the issues with a fast-moving JavaScript landscape and to extend our JavaScript support, we have recently released a completely rewritten client that supports multiple JavaScript frameworks.</p>\n<p>If you just want to dive into the documentation, <a href=\"../../docs/clients/javascript/index.md\">you can review that here</a>. If you want the story behind the rewrite, let's talk about some of the challenges we wanted to solve.</p>\n<ol>\n<li>Support for additional frameworks</li>\n<li>Bring the client up to modern JavaScript standards</li>\n<li>Have a little more code separation</li>\n<li>Provide a better developer experience</li>\n</ol>\n<p>We'll talk about each one of these points in a little more detail. But first, let's dive into the architecture a bit.</p>\n<p><img src=\"./exceptionless.drawio.png\" alt=\"Exceptionless JS architecture diagram\"></p>\n<p>Everything starts with Exceptionless JS Core. From there, we extend into specific environment implementations. The Node.js environment has different requirements than tha browser environment. Framework-specific environments like React and Vue have different requirements than the browser environment. By starting with the Core JS implementation, we can extend in any direction to any framework.</p>\n<p>Speaking of frameworks...</p>\n<h2>Support for additional frameworks</h2>\n<p>When Exceptionless launched, the JavaScript ecosystem was powered by Bower, front-end applications were built with jQuery, and supporting IE6 was a legitimate concern on the minds of many developers. Over time, the ecosystem grew. We got React, Vue, Express, Typescript support became popular, and React Native made it easy for web devs to jump into building mobile apps.</p>\n<p>While Exceptionless continued to work well for most use cases, it was clear we needed an updated client to support the exploding ecosystem. React Native was one of our specific targets because Exceptionless's JS client flat-out couldn't work in React Native. But while we were at it, we wanted to make Vue.js support easier, add some native React functionality, and more. What we arrived at is a more robust client with individual sub-clients for various frameworks.</p>\n<h2>Bring the client up to modern JavaScript standards</h2>\n<p>ECMAScript has progressed a lot in the last ten years. It was clear that we would need to re-write our client to keep up. With our new implementation, it will be much easier to stay on top of new features and experimental features.</p>\n<p>The JavaScript client is a set of ESM modules built on modern JavaScript, so Exceptionless is set now and into the future.</p>\n<h2>Have a little more code separation</h2>\n<p>This is not a question of monorepo or not. Instead, we recognized that we were trying to cover browser code and server code all in one package. This made things difficult, not to mention we didn't yet have support for specific frameworks (besides Angular 1.0).</p>\n<p>Since we knew we were going to extend our support, it made sense to rebuild the client in a way that allowed us to publish updates to specific sub-modules rather than to the entire core JavaScript client every time.</p>\n<h2>Provide a better developer experience</h2>\n<p>Developers are at Exceptionless's core. We are developers. We are part of the open-source community. Everything we build should make life easier for developers.</p>\n<p>This new version of our JavaScript client makes things significantly easier. Developers can reach for a specific client module, like Vue.js for example, rather than trying to shoehorn in a vanilla JavaScript client. React developers now have Error Boundary support built into the Exceptionless client. React Native developers can now use the client instead of writing raw API requests on their own.</p>\n<hr>\n<p>It took months of work, but the new Exceptionless JavaScript client is a completely rebuilt, all-new solution to event monitoring in JS. Exceptionless is proud to support the vibrant JavaScript ecosystem, and we believe this release positions us to update and stay ahead (or as close to ahead as anyone can get) of new JavaScript standards and updates into the future.</p>",
      "date_published": "2021-09-09T00:00:00Z"
    },
    {
      "id": "https://exceptionless.github.io/website/news/2021/2021-08-16-how-to-use-error-boundaries-in-react/",
      "url": "https://exceptionless.github.io/website/news/2021/2021-08-16-how-to-use-error-boundaries-in-react/",
      "title": "How To Use Error Boundaries in React",
      "content_html": "<p>Backend engineers have all the tools. Nice error handling. Reporting. Metrics. What about us frontend devs? Sure, we can catch errors in our functions, but what about errors in our presentational code? Take React for example. Write some bad code in your function component and the whole app crashes.</p>\n<p>Fortunately, frontend devs are getting more and more tools to help them with error handling. In fact, with the release of React 16, a new tool was added to the toolbox designed to specifically handle errors in components. <a href=\"https://reactjs.org/docs/error-boundaries.html\">Error Boundaries allow developers to catch and handle</a> errors in the presentational layer of React applications. From the React team's announcement:</p>\n<blockquote>\n<p>In the past, JavaScript errors inside components used to corrupt React’s internal state and cause it to emit cryptic errors on next renders. These errors were always caused by an earlier error in the application code, but React did not provide a way to handle them gracefully in components, and could not recover from them.</p>\n</blockquote>\n<p>That all changed with React 16. However, if you wanted to recover from a presentational layer error AND report it, there wasn't anything out of the box to help you. This is where <a href=\"https://exceptionless.com/?utm_source=first_signup&amp;utm_medium=blog&amp;utm_campaign=error_boundary\">Exceptionless</a> (an open-source error handling and monitoring tool) and React work really well together.</p>\n<p>Let's run through a quick tutorial that creates a React app that does the following:</p>\n<ul>\n<li>Creates an Error Boundary</li>\n<li>Forces an error in a function component</li>\n<li>Recovers from that error</li>\n<li>Reports it to our monitoring service (Exceptionless)</li>\n</ul>\n<h2>Getting Started</h2>\n<p>For this tutorial, you will need to have the following installed:</p>\n<ul>\n<li>Node.js v12 or greater</li>\n<li>NPM</li>\n<li>Text editor</li>\n<li><a href=\"https://exceptionless.com/?utm_source=second_signup&amp;utm_medium=blog&amp;utm_campaign=error_boundary\">Free account on Exceptionless</a></li>\n</ul>\n<p>With those things in place, let's generate our React app. From the command line, run the following:</p>\n<p><code>npx create-react-app error-boundary-example</code></p>\n<p>When your app is created, change into the directory and install the Exceptionless React package:</p>\n<p><code>cd error-boundary-example &amp;&amp; npm i @exceptionless/react</code></p>\n<p>This should get you set up with an app and the required package. Now, let's write a bit of code to show off the functionality. We'll walk through setting up an Error Boundary first.</p>\n<h2>Creating an Error Boundary in React</h2>\n<p>The first thing we need to do is create an Error Boundary file. This will act as a wrapper component for the rest of our application. In <code>src</code> folder of your React application, create a new file called <code>ErrorBoundary.js</code>. This will allow us to render a fallback when we hit an error in our component. We'll use Exceptionless's built-in Error Boundary to actually handle reporting the error. You'll see that soon, but let's focus on rendering the fallback for now.</p>\n<p>Inside your new file, add the following:</p>\n<pre><code class=\"language-js\">import React from &quot;react&quot;;\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        &lt;div&gt;\n          &lt;h1&gt;Uh oh!&lt;/h1&gt;\n          &lt;p&gt;\n            This wasn't supposed to happen. If you continue to see this message,\n            please reach out to support.\n          &lt;/p&gt;\n        &lt;/div&gt;\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n</code></pre>\n<p>This file will, again, wrap our main application code. So it will work throughout all of our components. If there's an error in a component, rather than totally crashing the application, it will render what we have in our render method here. You can change this to include whatever styling and information you'd like. I kept mine pretty simple.</p>\n<p>Now, we need to connect this to our application components.</p>\n<h2>Wrapping The App Component</h2>\n<p>You may have many providers in your application that all wrap your main <code>App</code> component. That's OK. This new Error Boundary component will simply wrap everything at the top level. Go to your <code>index.js</code> and update your file to look like this:</p>\n<pre><code class=\"language-js\">import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport ErrorBoundary from './ErrorBoundary';\n\nReactDOM.render(\n  &lt;React.StrictMode&gt;\n    &lt;ErrorBoundary&gt;\n      &lt;App /&gt;\n    &lt;/ErrorBoundary&gt;\n  &lt;/React.StrictMode&gt;,\n  document.getElementById('root')\n);\n\nreportWebVitals();\n</code></pre>\n<p>Now, before we handle reporting the error to Exceptionless, let's make sure this code works. Start up your application with <code>npm start</code>. We need to force an error. So, go into your <code>App.js</code> file and add an undefined variable into your component body:</p>\n<pre><code class=\"language-js\">import logo from './logo.svg';\nimport './App.css';\n\nfunction App() {\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;header className=&quot;App-header&quot;&gt;\n        &lt;p&gt;{undefinedVariable}&lt;/p&gt;\n        &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;\n        &lt;p&gt;\n          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.\n        &lt;/p&gt;\n        &lt;a\n          className=&quot;App-link&quot;\n          href=&quot;https://reactjs.org&quot;\n          target=&quot;_blank&quot;\n          rel=&quot;noopener noreferrer&quot;\n        &gt;\n          Learn React\n        &lt;/a&gt;\n      &lt;/header&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre>\n<p>You can see I've added <code>undefinedVariable</code> into the component. Because that variable is, well, undefined, the component will break. Save your code and check out the app. You'll see...</p>\n<p>...an error message still. What gives?</p>\n<p>Well, in development mode, React is going to try to help you out by rendering the error on screen. If you refresh the page, you should see your fallback component render for a split-second before the error appears on screen. When this code is deployed to a production environment, the error won't be displayed on screen. You know this because you've seen your production React apps crash. We all have. It shows a white screen. That's it. Now, though, your app will show the fallback screen.</p>\n<p>Pretty cool!</p>\n<p>Now, we need to make sure the error is reported back to our monitoring system. We will surely get emails from customers about this, but having the details handy might help us solve the problem before our support team can even get to those emails.</p>\n<h2>Capturing Errors</h2>\n<p>Now that we can display a message, Let's work on capturing the error and sending it to our reporting system—Exceptionless.</p>\n<p>The Exceptionless React package includes an Error Boundary helper called <code>ExceptionlessErrorBoundary</code>. All we need to do is import this into our <code>index.js</code> and wrap our <code>App</code> component with it. You'll need to grab yourself an API key from your Exceptionless account for this. You can <a href=\"../../docs/api/api-getting-started.md\">follow this guide to do so</a>.</p>\n<p>Let's take a look at what the code looks like. This is what you should update your <code>index.js</code> file to look like:</p>\n<pre><code class=\"language-js\">import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport {\n  Exceptionless, \n  ExceptionlessErrorBoundary\n} from &quot;@exceptionless/react&quot;;\nimport ErrorBoundary from './ErrorBoundary';\n\nconst startExceptionless = async () =&gt; {\n  await Exceptionless.startup((c) =&gt; {\n    c.apiKey = &quot;YOUR API KEY&quot;;\n    c.useDebugLogger();\n\n    c.defaultTags.push(&quot;Example&quot;, &quot;React&quot;);\n  });\n};\n\nstartExceptionless();\n\nReactDOM.render(\n  &lt;React.StrictMode&gt;\n    &lt;ErrorBoundary&gt;\n      &lt;ExceptionlessErrorBoundary&gt;\n        &lt;App /&gt;\n      &lt;/ExceptionlessErrorBoundary&gt;\n    &lt;/ErrorBoundary&gt;\n  &lt;/React.StrictMode&gt;,\n  document.getElementById('root')\n);\n\nreportWebVitals();\n</code></pre>\n<p>Now go back to your React app and re-load. You won't necessarily see it there, but the error event was sent to Exceptionless. Open up your Exceptionless dashboard and take a look at the Exceptions events:</p>\n<p><img src=\"./ErrorBoundaryException.png\" alt=\"exception events with error boundary example\"></p>\n<p>You can click into your exceptions to get more details. In this case, we will see what the variable was and the full stack trace for our React app.</p>\n<h2>Wrapping Up</h2>\n<p>Error Boundaries in React are powerful tools in helping you debug and quickly fix your applications. You can see how quickly we set this up to not only render a fallback UI and to report to an error monitoring service. You could write even less code and only report the error if you wanted to, but I'll leave that up to you.</p>\n<p>There are plenty of error monitoring services out there that you can plug this into, but if you're interested in an open-source solution, get started with <a href=\"https://exceptionless.com/?utm_source=third_signup&amp;utm_medium=blog&amp;utm_campaign=error_boundary\">Exceptionless</a> today.</p>",
      "date_published": "2021-08-16T00:00:00Z"
    },
    {
      "id": "https://exceptionless.github.io/website/news/2021/2021-04-19-navigating-the-exceptionless-world-of-go/",
      "url": "https://exceptionless.github.io/website/news/2021/2021-04-19-navigating-the-exceptionless-world-of-go/",
      "title": "Navigating The Exceptionless World of Go",
      "content_html": "<p>Go does not have the concept of exceptions. Welp, I guess <a href=\"https://exceptionless.com/\">Exceptionless</a> doesn't apply. Let's pack it up and head home, everyone.</p>\n<p>Kidding, of course. While Go really doesn't have the concept of exceptions, errors still happen in Go codebases, and those errors need to be handled. Having recently built an Exceptionless client in Go, we had the opportunity to take a deep dive into the Go programming language, and we'd like to share some of what we discovered along the way.</p>\n<h3>No Scrubs, No Exceptions</h3>\n<p><img src=\"https://media.giphy.com/media/ty48ztZKklU6k/giphy.gif\" alt=\"Gif of No Scrubs music video\"></p>\n<p>Let's take a quick look at why the Go programming language doesn't have exceptions, and then we can dive into how we work around this. From the Go FAQ:</p>\n<blockquote>\n<p>We believe that coupling exceptions to a control structure, as in the try-catch-finally idiom, results in convoluted code. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional.</p>\n</blockquote>\n<p>Essentially, Go doesn't want any scrubs (try/catch paradigm) hanging out the passenger side of their best friend's (that's you) ride trying to call things exceptions. Not everything is fatal. Not everything is an exception. Errors can happen without being so extraordinary to be considered an exception. As such, Go made the opinionated decision to simply not acknowledge exceptions as a construct.</p>\n<p>For those instances where an error is truly catastrophic, Go has some build in mechanism to handle and recover. Those are <a href=\"https://blog.golang.org/defer-panic-and-recover\">documented here</a>.</p>\n<p>So with no exceptions, how should errors be handled when using Exceptionless?</p>\n<h3>No Exceptions != No Errors</h3>\n<p>Just because there are no exceptions doesn't mean there are no errors. Fortunately, Go has a well-documented paradigm for handling errors without the need for something like an exception.</p>\n<p>Every function you write in Go can have multiple return values. So, a well-written function will return both an error and the actual function's response. Let's take a look at a very basic example of this.</p>\n<pre><code class=\"language-go\">package main \n\nimport ( \n\t&quot;github.com/go-errors/errors&quot;\n)\n\nfunc CombineStrings(string1 string, string2 string) (string, error) {\n\tvar errToReturn error\n\t\n  if string1 == &quot;&quot; || string2 == &quot;&quot; {\n    errToReturn = errors.New(fmt.Sprintf(&quot;Strings must have at least one character&quot;))\n  }\n\n  returnValue := string1 + string2\n\treturn returnValue, errToReturn\n}\n</code></pre>\n<p>In this example, we are using the <code>go-errors</code> module to build an error of the type <code>error</code>. We do a simple check to see if both of the string arguments to our function are not empty. If either is empty, we assign an error to the variable <code>errToReturn</code>. Then, in our return statement, we return both the expected return value of the function and the error.</p>\n<p>When calling this function, the developer needs to first check for an error before moving on. That might look like this:</p>\n<pre><code class=\"language-go\">combinedString, err := CombineString(&quot;hello, &quot;, &quot;world&quot;)\n\nif err != nil {\n  //Handle Error\n}\n\nfmt.Print(combinedString)\n</code></pre>\n<p>If an error is so bad that your code cannot execute any further, you may want to call Go's built in handler, <code>panic</code>, like this:</p>\n<pre><code class=\"language-go\">if err != nil {\n  panic(err)\n}\n</code></pre>\n<h3>Ok, So How Do We Use Exceptionless in an Exceptionless Environment?</h3>\n<p>Exceptionless (that's us) is a way of thinking about your code. It does not actually rely on the concepts of exceptions. In fact, Exceptionless is so much more than error/exception handling.</p>\n<p>So, with that framing, it becomes a lot more clear that Exceptionless can very easily be used within Go code to handle errors. In fact, the structure for using Exceptionless in Go is not all that different from other programming languages.</p>\n<p>We have a (currently as of the writing of this post) beta version of a <a href=\"https://github.com/exceptionless/Exceptionless.Go\">Go Exceptionless client</a>. You can find that here. I'll show you how to use the client, but do note that the client API could change until it's out of beta. The goal here is less about showing off the Go client and more about showing you how to handle errors with an event monitoring service within Go.</p>\n<p>The first thing you'll need to do is sign up for Exceptionless and get an API Key. <a href=\"https://exceptionless.com/\">You can sign up here</a>. Once you've done that, you'll need to install the Exceptionless Go client in your project. To do so, simply run the following:</p>\n<pre><code>go get https://github.com/exceptionless/Exceptionless.Go\n</code></pre>\n<p>Once that's installed, import it into your project like this:</p>\n<pre><code class=\"language-go\">import (\n  &quot;github.com/exceptionless/Exceptionless.Go&quot;\n)\n</code></pre>\n<p>Now, let's take a look at how we would use the client. On app startup (probably in your <code>main</code> function), you can initialize and configure the client like this:</p>\n<pre><code class=\"language-go\">func main() {\n  config := exceptionless.Exceptionless{\n    ApiKey: &quot;YOUR API KEY&quot;\n  }\n  exceptionless.Configure(config)\n}\n</code></pre>\n<p>With the Exceptionless client configured, you can now use it to handle all sorts of events in your app. We're going to focus in on exception—or, not exceptions as the case might be with go 😉.</p>\n<p>Let's use our example function from earlier as the example.</p>\n<pre><code class=\"language-go\">package main \n\nimport ( \n\t&quot;github.com/go-errors/errors&quot;\n  &quot;github.com/exceptionless/Exceptionless.Go&quot;\n)\n\nfunc SomOtherFunction() {\n  combinedString, err := CombineString(&quot;&quot;, &quot;world&quot;)\n\nif err != nil {\n  exceptionless.SubmitError(err)\n}\n\nfmt.Print(combinedString)\n}\n\nfunc CombineStrings(string1 string, string2 string) (string, error) {\n\tvar errToReturn error\n\t\n  if string1 == &quot;&quot; || string2 == &quot;&quot; {\n    errToReturn = errors.New(fmt.Sprintf(&quot;Strings must have at least one character&quot;))\n  }\n\n  returnValue := string1 + string2\n\treturn returnValue, errToReturn\n}\n</code></pre>\n<p>If you remember the <code>CombineStrings</code> function will return an error if either string is empty. So in my mock function <code>SomeOtherFunction</code>, I am calling <code>CombineStrings</code> and passing in an empty string. When the error comes back, all we need to do is handle it with Exceptionless using <code>exceptionless.SubmitError()</code>. Simple as that.</p>\n<h3>Conclusion</h3>\n<p>There is a lot more you could do. The Exceptionless Go client allows you to build custom events with more info. You could even bypass the client entirely and make an http request directly to the <a href=\"https://api.exceptionless.com/\">Exceptionless API</a> in your error handler.</p>\n<p>But the point is, despite Go being an exceptionless programming environment, you can catch errors and report them. So that means Exceptionless is actually a match made in heaven for the <em>exceptionless</em> environment of Go.</p>",
      "date_published": "2021-04-19T00:00:00Z"
    },
    {
      "id": "https://exceptionless.github.io/website/news/2021/2021-04-02-how-to-monitor-events-in-swift/",
      "url": "https://exceptionless.github.io/website/news/2021/2021-04-02-how-to-monitor-events-in-swift/",
      "title": "How To Monitor Events in Swift",
      "content_html": "<p>Swift, best known as the programming language that enables iOS, iPadOS, and macOS developers to build apps, has been growing in popularity over the years. <a href=\"https://www.zdnet.com/article/programming-language-popularity-apples-objective-c-tumbles-down-the-rankings/\">As of February of 2020</a>, it had leaped into the top-10 of most popular programming languages. While Swift can be used for more than just Apple platform products, we're going to keep things simple today and focus on how to set up event monitoring with Swift in an iOS app.</p>\n<p>For this tutorial, we're going to be using <a href=\"https://exceptionless.com/\">Exceptionless to collect events, so you'll need to sign up for a free account here</a>. You're also going to need the following:</p>\n<ul>\n<li>Mac computer (sorry Windows and Linux folks)</li>\n<li>Xcode</li>\n<li>Xcode command line tools</li>\n</ul>\n<h2>Getting Set Up</h2>\n<p>If you don't already have Xcode installed on your Mac, do so now. <a href=\"https://developer.apple.com/xcode/\">You can grab an install here</a>. If you already have it installed, you will need to make sure you are upgraded to Xcode 12. To check your version, open Xcode and check to see that you have version 12 or above. It'll look like this:</p>\n<p><img src=\"./xcode_version.png\" alt=\"Xcode version\"></p>\n<p>Once you're done installing it, you can check that everything was successful by either firing up Xcode or running the command I showed above. Now, we need to make sure you have the Xcode command line tools. These should be installed automatically when you install Xcode, but we want to be sure. To check if these were installed, run the following in Terminal:</p>\n<pre><code>xcode-select -p\n</code></pre>\n<p>If a path is printed out, you're all good. That's all you need. Open up Xcode, and we'll get started.</p>\n<h2>Creating a Project</h2>\n<p>Once you've opened Xcode, you're going to create a new project. Choose iOS and choose App, then click Next.</p>\n<p><img src=\"./create_app.png\" alt=\"iOS app creation in Xcode\"></p>\n<p>Next, you'll give the app a name in the Product Name section. I'll call mine Exceptionless Events. Make sure your interface is SwiftUI, your lifecycle is SwiftUI App, and your language is Swift. Then, click Next.</p>\n<p>You'll be asked where you want to store your code. Choose a folder that makes sense for you. When you've done that, your new project will load up. It should look like this:</p>\n<p><img src=\"./example_project.png\" alt=\"Example iOS project\"></p>\n<p>We're not going to spend a lot of time building an actual iOS app here, but we'll add enough functionality to test errors and test logging events. To set ourselves up, we're going to create two buttons in the UI. So, inside your <code>ContentView.Swift</code> file, replace the <code>Text</code> element with this:</p>\n<pre><code class=\"language-swift\">VStack{\n    Spacer()\n    Button(action: {}) {\n        Text(&quot;Log Message&quot;)\n    }\n    Spacer()\n    Button(action: {}) {\n        Text(&quot;Log Error&quot;)\n    }\n    Spacer()\n}\n</code></pre>\n<p>Note: the <code>Spacer</code> items are just there to make the screen a little more manageable (not necessarily prettier). Each button has a label and each has an action. However, the actions don't do anything just yet. We'll get that taken care of next.</p>\n<p>Above your <code>body</code> declaration, add these two functions:</p>\n<pre><code class=\"language-swift\">private func submitEvent() {\n    print(&quot;event&quot;)\n}\nprivate func submitError() {\n    print(&quot;error&quot;)\n}\n</code></pre>\n<p>Then, back inside your body, change each button's action to call the associated function like this:</p>\n<pre><code class=\"language-swift\">VStack{\n    Spacer()\n    Button(action: submitEvent) {\n        Text(&quot;Log Message&quot;)\n    }\n    Spacer()\n    Button(action: submitError) {\n        Text(&quot;Log Error&quot;)\n    }\n    Spacer()\n}\n</code></pre>\n<p>Just to test that everything is working, click the play button at the top of the Xcode window. This will build the app and launch a simulator. Click each button and make sure &quot;event&quot; and &quot;error&quot; print out in the console. Pro tip: the console may be shrunk down and hidden. At the bottom of your Xcode window, hover over the section that looks like this and drag to increase the window size so you can see the console.</p>\n<p><img src=\"./console.png\" alt=\"console example\"></p>\n<p>Assuming all is working, we can move on to using Exceptionless!</p>\n<h2>Creating the Exceptionless Class</h2>\n<p>We're going to handle all of the event processing and posting through a single class. You may want to refactor into multiple classes in a production project, but this will get the point across, I think.</p>\n<p>Let's create a new file. In the file menu bar, click File, New, File, and be sure to choose a Swift file and not SwiftUI. Let's name the new file <code>Exceptionless.swift</code>.</p>\n<p>Inside that file, we're going to create our <code>Exceptionless</code> class. Add the following so your file looks like this:</p>\n<pre><code class=\"language-swift\">import Foundation\n\nclass Exceptionless {\n    var apiKey: String\n    init(apiKey: String) {\n        self.apiKey = apiKey\n    }\n    \n    func submit(type: String, event: String) {\n        switch type {\n        case &quot;log&quot;:\n            print(&quot;log&quot;)\n        case &quot;error&quot;:\n            print(&quot;error&quot;)\n        default:\n            print(&quot;log&quot;)\n        }\n    }\n    \n    private func logMessage(logMessage: String) {\n       \n    }\n    \n    private func logError(errorEvent: String) {\n        \n    }\n}\n</code></pre>\n<p>This class doesn't do anything besides accept the Exceptionless API key, but you can see we're starting to frame out how to build our event monitoring system. To keep things simple, the <code>submit</code> function accepts a type of event (in string form) and it accepts the event string. The event string for the purposes of this example should be a simple log message or error message.</p>\n<p>Let's test what we have out so far. We want to connect our two buttons from earlier to the function, <code>submit</code>, that we created in the <code>Exceptionless</code> class. We should see the console print out &quot;log&quot; or &quot;error&quot; depending on what button we press.</p>\n<p>Back inside your <code>ContentView.swift</code> file, replace the actions for each button like this:</p>\n<pre><code class=\"language-swift\">var body: some View {\n    VStack{\n        Spacer()\n        Button(action: {Exceptionless.init(apiKey: &quot;YOUR API KEY&quot;).submit(type: &quot;log&quot;, event: &quot;Log Message&quot;)}) {\n            Text(&quot;Log Message&quot;)\n        }\n        Spacer()\n        Button(action:{Exceptionless.init(apiKey: &quot;YOUR API KEY&quot;).submit(type: &quot;error&quot;, event: &quot;Log Error&quot;)}) {\n            Text(&quot;Log Error&quot;)\n        }\n        Spacer()\n    }\n}\n</code></pre>\n<p>This is a very simplified example. In reality, your buttons would be calling some other action and you'd be catching errors or logging events dependent on what that action does. Let's test this out, though. We don't actually need an API Key yet, so leave the <code>apiKey</code> string as is. Run your project on a simulator and click each button. You should see &quot;log&quot; and &quot;error&quot; printed in the console.</p>\n<p>Congratulations! You just built a class within Swift that will act as the framework for submitting events.</p>\n<h2>Building Events</h2>\n<p>We're going to keep things simple. <a href=\"https://api.exceptionless.io/docs/index.html\">The Exceptionless API</a> has some great documentation and some simple examples that we'll be making use of. Let's start by updating out switch statement to actually call the functions specific to events or errors:</p>\n<pre><code class=\"language-swift\">func submit(type: String, event: String) {\n    switch type {\n    case &quot;log&quot;:\n        return logMessage(logMessage: event)\n    case &quot;error&quot;:\n        return logError(errorEvent: event)\n    default:\n        print(&quot;log&quot;)\n    }\n}\n</code></pre>\n<p>You can do whatever you'd like with your default case. I'm going to keep it as a print statement, though. What we've done is we've said if we call <code>submit</code> with a type of &quot;log&quot;, we will call the <code>logMessage</code> function. If we call <code>submit</code> with a type of &quot;error&quot;, we will call the <code>logError</code> function.</p>\n<p>Let's build out the <code>logMessage</code> function fist. Replace the existing empty function with this:</p>\n<pre><code class=\"language-swift\">private func logMessage(logMessage: String) {\n    let now = Date()\n    let formatter = ISO8601DateFormatter()\n    let datetime = formatter.string(from: now)\n    let eventDictionary : [String: Any] = [ &quot;type&quot;: &quot;log&quot;, &quot;message&quot;:logMessage, &quot;date&quot;: datetime ]\n    let jsonData = (try? JSONSerialization.data(withJSONObject: eventDictionary, options: []))!\n    let jsonString = String(data: jsonData, encoding: String.Encoding.ascii)!\n    print (jsonString)\n}\n</code></pre>\n<p>Because the Exceptionless API takes JSON body payloads, we want to build our event into JSON. To do that, we first start with a dictionary. As you can see, we are creating an <code>eventDictionary</code> which is simply keyvalue pairs in string format. We add in the date in ISO format so we know when our events happen. The actual event message is what we passed in all the way back from when we clicked the button.</p>\n<p>We take that dictionary and convert it to JSON with Swift's built-in <code>JSONSerialization</code> function. Before posting to the API, let's take a look at the output in the console and make sure we're happy with it.</p>\n<p>Build and run the app, then click &quot;Log Message&quot;. You should see the following printed in the console:</p>\n<pre><code>{&quot;message&quot;:&quot;Log Message&quot;,&quot;date&quot;:&quot;2021-04-05T13:34:39Z&quot;,&quot;type&quot;:&quot;log&quot;}\n</code></pre>\n<p>Your date will, of course, be different.</p>\n<p>Ok, we've gotten this far. Let's build our error function. Don't worry, we'll come back and think about how we want to actually post these events to Exceptionless.</p>\n<p>Replace the empty <code>logError</code> function with this:</p>\n<pre><code class=\"language-swift\">private func logError(errorEvent: String) {\n    let now = Date()\n    let formatter = ISO8601DateFormatter()\n    let datetime = formatter.string(from: now)\n    \n    let errorDictionary : [String: Any] = [&quot;message&quot;: errorEvent, &quot;type&quot;: &quot;System.Exception&quot;]\n    \n    let errorJson = (try? JSONSerialization.data(withJSONObject:errorDictionary, options: []))!\n    let errorJsonString = String(data: errorJson, encoding: String.Encoding.ascii)!\n    let eventDictionary : [String: Any] = [ &quot;type&quot;: &quot;error&quot;, &quot;@simple_error&quot;:errorJsonString, &quot;date&quot;: datetime ]\n    let jsonData = (try? JSONSerialization.data(withJSONObject: eventDictionary, options: []))!\n    let jsonString = String(data: jsonData, encoding: String.Encoding.ascii)!\n    print (jsonString)\n}\n</code></pre>\n<p>You'll see this function is very similar to the <code>logMessage</code> function. However, we are nesting data in our JSON, so we need two dictionaries. We use one dictionary to house the &quot;@simple_error&quot; and another to house the entire event. In other words, nest the JSON version of our <code>errorDictionary</code> inside the JSON version of our <code>eventDictionary</code>.</p>\n<p>Let's build and run the app and try both buttons. You should see the following printed out:</p>\n<pre><code>{&quot;message&quot;:&quot;Log Message&quot;,&quot;date&quot;:&quot;2021-04-05T13:46:58Z&quot;,&quot;type&quot;:&quot;log&quot;}\n{&quot;type&quot;:&quot;error&quot;,&quot;@simple_error&quot;:&quot;{\\&quot;message\\&quot;:\\&quot;Log Error\\&quot;,\\&quot;type\\&quot;:\\&quot;System.Exception\\&quot;}&quot;,&quot;date&quot;:&quot;2021-04-05T13:46:59Z&quot;}\n</code></pre>\n<p>Your dates will be different, but the rest should look about the same. We now have a Log Event AND an Error Event. I think we're ready to post to the Exceptionless API.</p>\n<p>Remember, if you haven't done so, you'll need to sign up for a <a href=\"https://exceptionless.com/\">free Exceptionless account</a>, create a project, and grab an API Key.</p>\n<h2>Posting To The API</h2>\n<p>When we post to the Exceptionless API, we are posting JSON data. In the examples above, we are printing the JSON string version of what we will ultimately push to the API. Let's see how it will look when actually posting to the API.</p>\n<p>Within our Exceptionless class, let's create a new private function called <code>postToAPI</code>.</p>\n<pre><code class=\"language-swift\">private func postToApi(event: Data) {\n    let url = URL(string: &quot;https://collector.exceptionless.com/api/v2/events&quot;)!\n\n    var request = URLRequest(url: url)\n    request.httpMethod = &quot;POST&quot;\n\n    // insert json data to the request\n    request.httpBody = event\n    request.setValue(&quot;application/json; charset=utf-8&quot;,\n         forHTTPHeaderField: &quot;Content-Tye&quot;)\n    request.setValue(&quot;application/json; charset=utf-8&quot;,\n         forHTTPHeaderField: &quot;Accept&quot;)\n    request.setValue(&quot;Bearer &quot; + self.apiKey,\n         forHTTPHeaderField: &quot;Authorization&quot;)\n\n    let task = URLSession.shared.dataTask(with: request) { data, response, error in\n        guard let data = data, error == nil else {\n            print(error?.localizedDescription ?? &quot;No data&quot;)\n            return\n        }\n        let responseJSON = try? JSONSerialization.jsonObject(with: data, options: [])\n        if let responseJSON = responseJSON as? [String: Any] {\n            print(responseJSON)\n        }\n    }\n\n    task.resume()\n}\n</code></pre>\n<p>Walking through this new function, let's take a look at what's going on. First, we are setting the URL for our API request. This is a hardcoded value and probably not something you'd want to do in a production application.</p>\n<p>Next, we are creating a new request and assigning values to the request. You'll note that our <code>postToAPI</code> function accepts a <code>Data</code> value argument called <code>event</code>. That is what we will be posting to the API and it represents the JSON version of the event we build when we click Log Message or Log Error.</p>\n<p>Then, we set header values for our request. Take note, that we are assigning the <code>Authorization</code> value by using our Exceptionless API key. We'll need to get that key from Exceptionless before actually sending events. \\</p>\n<p>Finally, we are posting the request using <code>URLSession</code>.</p>\n<p>To actually call this function, we need to make two minor changes. First, back in your <code>ContentView.swift</code> file, we need to add our Exceptionless API key in where we left placeholder text. Again, this is not how you'd assign the API Key in a production app, but it's a simple example to get you going.</p>\n<p>Now, back in the <code>Exceptionless.swift</code> file, let's update both the <code>logMessage</code> and <code>logError</code> functions. Instead of converting our event to a JSON string, we're going to leave it as JSON and pass it through to our <code>postToAPI</code> function like this:</p>\n<pre><code class=\"language-swift\">private func logMessage(logMessage: String) {\n    let now = Date()\n    let formatter = ISO8601DateFormatter()\n    let datetime = formatter.string(from: now)\n    let eventDictionary : [String: Any] = [ &quot;type&quot;: &quot;log&quot;, &quot;message&quot;:logMessage, &quot;date&quot;: datetime ]\n    let jsonData = (try? JSONSerialization.data(withJSONObject: eventDictionary, options: []))!\n    postToApi(event: jsonData)\n}\n</code></pre>\n<p>And here's the <code>logError</code> function:</p>\n<pre><code class=\"language-swift\">private func logError(errorEvent: String) {\n    let now = Date()\n    let formatter = ISO8601DateFormatter()\n    let datetime = formatter.string(from: now)\n    \n    let errorDictionary : [String: Any] = [&quot;message&quot;: errorEvent, &quot;type&quot;: &quot;System.Exception&quot;]\n    \n    let errorJson = (try? JSONSerialization.data(withJSONObject:errorDictionary))!\n    let errorJsonString = String(data: errorJson, encoding: String.Encoding.ascii)!\n    let eventDictionary : [String: Any] = [ &quot;type&quot;: &quot;error&quot;, &quot;@simple_error&quot;:errorJsonString, &quot;date&quot;: datetime ]\n    let jsonData = (try? JSONSerialization.data(withJSONObject: eventDictionary))!\n\n    postToApi(event: jsonData)\n}\n</code></pre>\n<p>Go ahead and build and run your app. Click the Log Message button and then the Log Error button. You won't see anything printed in the console, but if you go into your Exceptionless dashboard, you should see a new log and a new exception.</p>\n<p><img src=\"./example_swift_events.png\" alt=\"Exceptionless dashboard\"></p>\n<p>Congratulations! You just built a simple event monitoring service in native Swift code. You can extend this pretty easily thanks to the Exceptionless class and leverage it in a production application.</p>\n<p>Swift is a fun language, but when using it to build mobile applications, it can be difficult to debug and track events. Exceptionless can help, and hopefully this tutorial shows how to implement such event tracking in SwiftUI and Swift.</p>\n<p>If you'd like to see the sample Xcode project, <a href=\"https://github.com/exceptionless/Exceptionless-Swift-Example\">we have a repo for it here</a>.</p>",
      "date_published": "2021-04-02T00:00:00Z"
    },
    {
      "id": "https://exceptionless.github.io/website/news/2021/2021-03-24-how-to-build-a-custom-go-api-client/",
      "url": "https://exceptionless.github.io/website/news/2021/2021-03-24-how-to-build-a-custom-go-api-client/",
      "title": "How to Build a Custom Go Client For a REST API",
      "content_html": "<p><img src=\"./go_gophers.jpg\" alt=\"Picture of gophers working\"></p>\n<p><a href=\"https://exceptionless.com/\">Exceptionless</a> is powered by a REST API. When you interact with the dashboard UI, when you use the .NET client, and when you use the JavaScript client, you are interacting with the REST API. It is well-documented, and it can be used without any client libraries. This paradigm makes it simple for developers to create their own wrappers around the API. In fact, we recently started work on building an official Go client for Exceptionless. Along the way, we learned some tips and tricks that may be helpful for others that want to build clients and SDKs in Go that wrap RESTful APIs.</p>\n<p>First, a little about Go. <a href=\"https://golang.org/\">Go</a> is a statically typed language, built originally by the folks at Google. Go, while close in syntax to many other statically typed languages, differs in that it is no object oriented. Go is also very well suited for <a href=\"https://www.programmableweb.com/news/what-grpc-api-and-how-does-it-work/analysis/2020/10/08\">gRPC APIs</a>, but that does not prevent it from being used with REST APIs, as we'll see here today.</p>\n<h3>Getting Started</h3>\n<p>In order to build our Go client, we will need to have Go installed. Honestly, this can be the hardest step as it involves setting environment variables and updating your profile source PATH. So rather than risk confusing you with the steps to install Go and get started, I'm going to simply point you to Go's official install instructions.</p>\n<p><a href=\"https://golang.org/doc/install\">You can find those instructions here</a>.</p>\n<p>Once you've installed Go, you will need to have a text editor handy so that we can write our new Go code. From the command line, create a new folder and call it &quot;go-rest&quot;. Change into that directory, and let's start writing some code.</p>\n<h3>The Main File</h3>\n<p>In Go, you will always have a <code>main.go</code> file which acts as the entry point for your source code. We need to set that up first, so let's do that now. In the root of your project folder, create your <code>main.go</code> file. Inside that file, let's start by declaring our package and importing a module. Add the following:</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n)\n</code></pre>\n<p>Your file won't do anything yet, but we're laying the groundwork. We have declared our package as <code>main</code>, and we have imported the built-in <code>fmt</code> library from Go for formatting.</p>\n<p>Next, we need a <code>main</code> function, so let's create that. Add the following below your import statement:</p>\n<pre><code class=\"language-go\">func main() {\n  fmt.Println(&quot;Hello, world&quot;)\n}\n</code></pre>\n<p>This is the example program Go's example docs show, so we might as well run it. From your command line, inside your project directory, run this command:</p>\n<pre><code>go run .\n</code></pre>\n<p>You should see <code>Hello, world</code> printed in the command line terminal window.</p>\n<p>Now that we have the fundamentals down, let's talk about how Go works so that we can build our REST API client. You can include as many functions in your <code>main.go</code> file as you'd like and you can call those function from within other functions. But, like any other programming language, it's probably smart to separate code to make it easier to work with.</p>\n<h3>Creating an API Helper</h3>\n<p>The nice thing about Go is that when you create a new file, that file is automatically available from any of your other files as long as they share the same main package.</p>\n<p>Since we are building a REST client, it probably makes sense to create a file that would handle all our API routing request. So, create a file in the root of your project called <code>api.go</code>.</p>\n<p>Inside that file, make sure to reference the main package at the top like this:</p>\n<p><code>pacakage main</code></p>\n<p>We are also going to import a couple packages here as well, so your file should look like this:</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t&quot;bytes&quot;\n\t&quot;log&quot;\n\t&quot;net/http&quot;\n)\n</code></pre>\n<p>These packages are all built into Go itself. You can install external packages as well, and we'll explore that soon.</p>\n<p>Now that we have the start of our API file, it's good to think about what our client needs to do. With a REST API, you may have the following request methods:</p>\n<ul>\n<li>GET</li>\n<li>POST</li>\n<li>PUT</li>\n<li>DELETE</li>\n<li>PATCH</li>\n</ul>\n<p>You may not need all of these for your client, but it's good to know that they exist. In our case, we are going to implement the GET and POST methods and with those as a template, you should be able to extend your code to implement PUT, PATCH, and DELETE.</p>\n<p>Let's start by building the POST method since its the backbone of our client. In your <code>api.go</code> file, below the import statement, add the following:</p>\n<pre><code class=\"language-go\">//Post posts to the Exceptionless Server\nfunc Post(endpoint string, postBody string, authorization string) string {\n\tbaseURL := &quot;YOUR API URL/&quot;\n\turl := baseURL + endpoint\n\tvar jsonStr = []byte(postBody)\n\treq, err := http.NewRequest(&quot;POST&quot;, url, bytes.NewBuffer(jsonStr))\n\treq.Header.Set(&quot;Authorization&quot;, &quot;Bearer &quot;+authorization)\n\treq.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;)\n\tclient := &amp;http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\treturn string(resp.Status)\n}\n</code></pre>\n<p>In our real-world use case, we are making requests to the Exceptionless API, so we know the post body needs to be a JSON string. This is why the <code>postBody</code> is of type <code>string</code>. If your API is expecting a different format, make sure you type your variable properly here. The other two arguments in our <code>Post</code> function are pretty self explanatory. The <code>endpoint</code> string is the endpoint on your API you want to call. The <code>authorization</code> string is the token/API key needed to authenticate into the API. You could choose to handle the authorization differently, if you wanted. For example, if your API expected basic authentication, your authorization variable might be a string mapping of username and password.</p>\n<p>One of the tricks here is if you are sending JSON to your REST API, you will need to convert the body into a format the http client library within Go can handle. We're doing that with the <code>bytes.NewBuffer(jsonStr)</code> call.</p>\n<p>Now, let's put together our <code>GET</code> function:</p>\n<pre><code class=\"language-go\">//GET makes api GET requests\nfunc Get(endpoint string, authorization string) map[string]interface{} {\n\tbaseURL := &quot;YOUR API URL/&quot;\n\n\turl := baseURL + endpoint\n\n\thttpClient := &amp;http.Client{}\n\treq, err := http.NewRequest(&quot;GET&quot;, url, nil)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\treq.Header.Add(&quot;accept&quot;, &quot;application/json&quot;)\n\treq.Header.Add(&quot;Authorization&quot;, &quot;Bearer &quot;+authorization)\n\n\tres, err := httpClient.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tvar result map[string]interface{}\n\tjson.Unmarshal([]byte(body), &amp;result)\n\treturn result\n}\n</code></pre>\n<p>Much like out <code>POST</code> request, our <code>GET</code> request takes in arguments. We only need the <code>endpoint</code> and the <code>authorization</code> arguments for this function. This function is pretty straight forward. However, if you want to read the response as JSON, you need to take an extra step as I've shown above.</p>\n<p>You will want to a string mapping by unmarshaling the JSON returned by the API. Of course, your API may not return JSON, so use this accordingly. If you do need to unmarshal the JSON, you simply need to pass the response body into the <code>json.Unmarshal()</code> as shown above.</p>\n<p>These two functions should help you build your other REST-related functions. Now, let's take a look at helper functions that will make your client easy to use while sending the correct data to your API.</p>\n<h2>Convenience Functions</h2>\n<p>A good SDK or client API wrapper will include helper functions so the developer using it doesn't have to still manually build requests to your API. The best way to build helper functions is to start with your data model. Let's say, for example, your API expects a JSON payload like this:</p>\n<pre><code class=\"language-json\">{\n\t&quot;BookTitle&quot;: &quot;The Great Gatsby&quot;, \n\t&quot;Author&quot;: &quot;F. Scott Fitzgerald&quot;, \n\t&quot;Rating&quot;: 7\n}\n</code></pre>\n<p>In this case, we'd probably want to create a struct type variable that we can use to build our payload for the reqest. That might look like this:</p>\n<pre><code class=\"language-go\">type BookRating struct {\n\tBookTitle       string\n\tAuthor          string\n\tRating \t\t\t\t\tuint\n}\n</code></pre>\n<p>A quick note on Go variables and functions. If the variable or the function name is capitalized, it is exported and available throughout your program.</p>\n<p>Now that we have a struct we can use, we can start to build a helper function that would build a payload for our API. In keeping with the example in the JSON and the struct above, let's pretend our API take a <code>POST</code> request to rate a specific book. For some reason, our API needs the string title and string author of the book, and it needs an interger for the rating. You might create a helper function like this:</p>\n<pre><code class=\"language-go\">func RateBook(title string, author string, rating uint): bool {\n\tnewRating := BookRating{\n\t\tBookTitle: title, \n\t\tAuthor: author, \n\t\tRating: rating\n\t}\n\n\tjson, err := json.Marshal(newRating)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn false\n\t}\n\n\tresp, err := Post(&quot;rateBook&quot;, string(json), &quot;API KEY&quot;)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn false\n\t}\t\n\n\treturn true\n}\n</code></pre>\n<p>In the <code>RateBook</code> function, we are allowing the developer to simply pass in the title, author, and the rating. We then build the JSON payload for the developer and send it to the <code>Post</code> function we created earlier. When we are building the JSON payload, we must use <code>json.Marshal</code> to convert our struct to a type that can be used with our REST API.</p>\n<p>You'll note, the authorization argument in the above example is &quot;API KEY&quot;, but a good SDK will have stored that API Key when the client was initialized. I'll leave it up to you on how you'd like to handle this, but it could be as simple as calling <code>Configure</code> function with the developer's API Key and storing the key in memory.</p>\n<h2>Wrapping Up</h2>\n<p>This is a simple example of how you might build a Go client for a REST API. The concepts are general, but they hopefully help you if you find yourself needing to build your own client. Exceptionless will be launching its own Go client soon. If you haven't tried Exceptionless for your application's event monitoring, <a href=\"https://exceptionless.com/\">give it a shot now</a>.</p>",
      "date_published": "2021-03-24T00:00:00Z"
    },
    {
      "id": "https://exceptionless.github.io/website/news/2021/2021-02-22-how-to-debug-electron-apps/",
      "url": "https://exceptionless.github.io/website/news/2021/2021-02-22-how-to-debug-electron-apps/",
      "title": "How to Debug Electron Apps",
      "content_html": "<p>Electron is a great framework that makes developing cross-platform desktop applications easy. If you're a JavaScript developer, it is probably the first thing you'll reach for when you decide to build a desktop application. I know I did. In building my first and second desktop applications, I used Electron. In that process, I learned some tricks to help the development process go a little smoother. One such trick is how to better debug issues that may arise in the packaged, production version of your Electron app that you won't see in development.</p>\n<p>If you're not familiar with <a href=\"https://www.electronjs.org/\">Electron</a>, it is a framework that allows you to write apps with web technologies and use them on the desktop. This is accomplished by packaging your app within its own dedicated Chromium-based application. Think of a web browser. All it is is a desktop application that allows you to explore web apps and web pages. That's what Electron does for your app. It creates a one off desktop browser. In doing so, you get access to native desktop functionalities that are not available to traditional web applications.</p>\n<p>Like with many software projects, you might find that your local development experience doesn't exactly match what happens in production. When an app is minified, built, compiled, and packaged for production use, there can be subtle changes that can break the experience of the application or break the app entirely. This is especially true when dealing with desktop applications that have more access than you might be used to with web apps. Debugging problems when your application works locally but doesn't work in its production state can be frustrating. This becomes even more frustrating in Electron when you only have access to the web application's JavaScript output in production and not the underling Electron code's output. Fortunately, we can solve this by using an error monitoring service.</p>\n<p>We're going to be making use of <a href=\"https://exceptionless.com/\">Exceptionless</a> and the Exceptionless JavaScript client to debug and monitor our Electron application. Exceptionless is free to get started and totally open-source. Let's get started.</p>\n<p>From within your Electron app's project directory run <code>npm i exceptionless</code>.</p>\n<p>Now, we can configure the Exceptionless client and use it anywhere. This means we can use it in both the &quot;front end&quot; (web app) code and the &quot;back end&quot; Electron code. For the sake of this tutorial, we are only going to be focusing on the Electron code. Inside your <code>main.js</code> file, add the following below your other import/require statements:</p>\n<pre><code>const { ExceptionlessClient } = require(&quot;exceptionless&quot;)\nconst client = ExceptionlessClient.default.config.apiKey = &quot;YOUR API KEY&quot;\n</code></pre>\n<p>You can get your project API key in the Exceptionless project settings page.</p>\n<p>Now, with the client configured, you can start using Exceptionless to log events. The cool thing is these don't need to just be errors. If you want to log when a particular function is called within your main Electron code, you can use <code>client.submitLog(&quot;Function called&quot;)</code> but with something more descriptive. By submitting log events for particular functions, you will know for sure the function is being called. Of course, you can and should also track errors. This is as simple as calling <code>client.submitException(error)</code> with your error.</p>\n<p>This is all very abstract, though. So, let's look at a practical example. Let's say your Electron app is listening to some event in order to write some data to the computer's hard disk. We need a trigger to come from our &quot;frontend&quot; html/js code, and then we need to read that trigger and take some action. In Electron, we use <code>ipcMain</code> to listen for events from the frontend code. An example of this might look like:</p>\n<pre><code class=\"language-javascript\">ipcMain.on(&quot;Save File&quot;, async (event, message) =&gt; {\n  try {\n    await fs.writeFileSync(&quot;/path/to/where/you/want/to/store/the/file&quot;, message)\n    client.submitLog(`Wrote file successfully with the following content: ${message}`)\n  } catch(e) {\n    client.submitException(e)\n  }\n});\n</code></pre>\n<p>I added a log event that is sent to Exceptionless in the try and I catch the error and send that to Exceptionless in the catch. The beauty of this is we know when the event is successful, which is comforting, but we also know when it fails and why. This is important, because a failure here would be a silent failure in your app.</p>\n<p>Let's say the file path you think you're trying to write to does not exist after your Electron app is built and packaged (a common issue is that PATH variables exposed by default to applications can be different than what you use and have available in your development environment). If that path did not exist, the <code>writeFileSync</code> command would not work. You would have no idea why, and your users would only know it when they tried to fetch the file that should have been written.</p>\n<p>Imagine trying to debug that without error and event monitoring. You'd fire it up locally on your machine, run some tests, try to replicate the steps exactly as the user did them. And everything would work. You wouldn't see the error because your development environment is just different enough from the production environment to keep you from realizing that the write path in production doesn't exist.</p>\n<p>There are a million other ways your Electron app can fail silently. By adding error and event monitoring, you can quickly debug problems that would otherwise have you banging your head off your desk.</p>",
      "date_published": "2021-02-22T00:00:00Z"
    },
    {
      "id": "https://exceptionless.github.io/website/news/2021/2021-01-26-saying-thanks-to-the-open-source-community-through-sponsorship/",
      "url": "https://exceptionless.github.io/website/news/2021/2021-01-26-saying-thanks-to-the-open-source-community-through-sponsorship/",
      "title": "Saying Thanks to the Open Source Community Through Sponsorship",
      "content_html": "<p>Exceptionless has always been committed to the open-source software ecosystem. In fact, <a href=\"https://github.com/Exceptionless\">Exceptionless is entirely open-source</a>, and we try our best to make it easy for anyone to host their own instance of our software. Our main repository has nearly 2,000 stars on Github and has seen contributions from 26 different people. Across all our repositories, we've seen hundreds of issues opened, dozens of pull requests, and countless comments. And for all of that, we are so appreciative. But we wanted to show our appreciation by doing more than just saying thanks.</p>\n<h2>Thanking Open Source Contributions Through Sponsorship</h2>\n<p>Today, we're excited to announce that <a href=\"https://github.com/sponsors/benaadams\">we have sponsored Ben Adams</a> through the Github Sponsors program. As you all know, we are huge fans of .NET, and Exceptionless is one of the only monitoring tools built around the .NET ecosystem first. Ben, like us, cares deeply about open-source software and the .NET community. We hope that by sponsoring him, we will be giving back in a tangible way, not just to Ben but to the sustainability of open-source.</p>\n<p>Before diving into more about who Ben is and why we're sponsoring him specifically, it might be good to reflect on the importance of sustainable open-source development. Exceptionless survives through a hosted service, but many open-source projects don't have that option. This leaves maintainers in the unenviable position of having to write software, fix bugs, and respond to issues while receiving nothing more than &quot;thanks&quot; as payment.</p>\n<p>&quot;Thanks&quot; doesn't pay the bills. Exposure doesn't pay the bills.</p>\n<p>We don't want to see open-source developers shut down their projects. We want developers to have optionality. <a href=\"https://medium.com/@kitze/github-stars-wont-pay-your-rent-8b348e12baed\">A quote from Kitze</a>, the founder of Sizzy and other products, really illustrates this sentiment well:</p>\n<blockquote>\n<p>Open source, writing blog posts, and playing with tweaking lint settings and editor themes all day are completely fine until your landlord knocks on your door or you’re at the checkout at the grocery store.</p>\n</blockquote>\n<p>It's not just the viability of creating open-source software that becomes a problem, it's also the long-term sustainability when larger companies use that software. When we see companies like Amazon abuse open-source contributions, we see a door closing on the viability of software that is designed to survive through community and contribution.</p>\n<p>So, while Exceptionless might not change the world by itself with its sponsorship, we want to lead by example. As Kitze said, Github stars don't pay the bills, but money does. So, we're opening our wallet and helping Ben Adams do what he's done so well for years.</p>\n<h2>Ben Adams</h2>\n<p><img src=\"./benadams.png\" alt=\"Ben Admas Github Profile\"></p>\n<p>Ben has been working on open-source projects for years. He has thousands of contributions across dozens of repositories. In fact, he is so prolific in his .NET contributions that everyone else with more contributions than him are Microsoft employees. It doesn't get more impressive than that. Here's a quick summary of Ben's open-source contributions:</p>\n<ul>\n<li>His projects have 2,600 Github stars (which, again, don't pay the bills 😉)</li>\n<li>He has over 20,000 commits</li>\n<li>He has contributed to 25 different projects</li>\n<li>He's opened over 1,500 pull requests</li>\n</ul>\n<p>It should be clear by now that Ben knows his stuff. As mentioned before, Ben cares a whole lot about .NET, and so do we. So, this sponsorship makes perfect sense for us.</p>\n<p>For the gamers and the game developers, Ben has you covered too. He is the CTO of Illyriad Games which makes <a href=\"https://www.ageofascent.com/\">Age of Ascent</a>. Age of Ascent is a real-time MMO that puts players in the cockpits of fighter ships in space. As you might expect, the game's tech stack <a href=\"https://youtu.be/dqYlKkexth0\">makes heavy use of .NET</a> and other Microsoft-related services.</p>\n<p>Other people recognize Ben's contributions too:</p>\n<blockquote>\n<p>Since the beginning of the .NET Core journey we’ve had some amazing contributors but I seriously enjoy working with\n@ben_a_adams!\n-<a href=\"https://twitter.com/davidfowl/status/1353087429364879361\">David Fowler</a></p>\n</blockquote>\n<blockquote>\n<p>There's smart, then there's crazy. Then there's Crazy Smart. That's Ben (and he's a lovely chap, too)!\n-<a href=\"https://twitter.com/bitcrazed/status/1354144181837414400\">Rich Turner</a></p>\n</blockquote>\n<blockquote>\n<p>Junior .Net Developer\nSenior .Net Developer\nBen Adams .Net Developer\n😁 😁 😁\n-<a href=\"https://twitter.com/MarcoRossignoli/status/1166733777206468608\">Marco Rossignoli</a></p>\n</blockquote>\n<h2>How Does Sponsorship Work?</h2>\n<p>Github Sponsors allows each developer to define what comes along with sponsorship at various levels. Ben was gracious enough to offer his own development time to Gold Level sponsors, and we simply could not pass that up. While we would be happy to simply sponsor Ben's work, having him contribute code to our open-source repositories will help Exceptionless take a major step forward.</p>\n<p>Sponsoring open-source developers is not a new concept, but having it built into Github has help elivate the visibility of portential sponsorship opportunities. We hope that by having companies like Exceptionless sponsor (and publicize those sponsorships) developers, it will encourage others to do the same. Open-source sustainability still has a long way to go, but any step forward we can help the ecosystem take, we're willing to do it.</p>\n<p>Thanks so much, Ben! We look forward to working with you and following your continued contributions across the open-source community.</p>",
      "date_published": "2021-01-26T00:00:00Z"
    },
    {
      "id": "https://exceptionless.github.io/website/news/2021/2021-01-19-how-to-use-react-hooks-to-monitor-events-in-your-app/",
      "url": "https://exceptionless.github.io/website/news/2021/2021-01-19-how-to-use-react-hooks-to-monitor-events-in-your-app/",
      "title": "How to Use React Hooks to Monitor Events in Your App",
      "content_html": "<p>The <a href=\"https://reactjs.org/docs/hooks-intro.html\">introduction of Hooks in React</a> was a game-changer. Developers now had options when it came to creating stateful components. It used to be that if you had a stateful component, you'd have to use a class component, and if you had a presentational component, you could choose between a class or a function component. Now, with hook, state can be managed inside function components. But that's not all Hooks did for React developers.</p>\n<p>Hooks introduced a better way to reuse stateful functions. Today, we're going to explore how to build a custom React hook that will allow us to monitor events in our application. Those events can be errors, messages, feature usage, logs, or anything you want. There are plenty of error monitoring services out there, but we're going to make use of <a href=\"https://exceptionless.com/\">Exceptionless</a> for three reasons:</p>\n<ol>\n<li>Real-time updates</li>\n<li>It's open-source</li>\n<li>The Exceptionless JavaScript client gives us a singleton option (which makes for a good example in this post)</li>\n</ol>\n<p>Let's get started by starting a new React project. You'll need to have the following available on your machine:</p>\n<ul>\n<li>Node &gt;= 8.10</li>\n<li>npm &gt;= 5.6</li>\n<li>Text editor</li>\n</ul>\n<p>Assuming you have that ready, open up a terminal. To create a new React project, simply run:</p>\n<p><code>npx create-react-app Monitoring-App</code></p>\n<p>Replace <code>Monitoring-App</code> with whatever you'd like to call your project. When everything is done, change into your new application's directory (<code>cd Monitoring-App</code>). Now, we need to install the Exceptionless JavaScript client.</p>\n<p>To do so, simple run:</p>\n<p><code>npm install exceptionless</code></p>\n<p>When that's done installing, start your app (<code>npm start</code>) and open your project directory in the text editor of your choice.</p>\n<h3>What are Hooks?</h3>\n<p>React's docs have the simplest definition of Hooks and I think it's worth calling that out here:</p>\n<blockquote>\n<p>Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.</p>\n</blockquote>\n<p>The popularity of classes in JavaScript in general has oscillated greatly. However, within the React ecosystem, it was the ONLY option for creating components that could actually do <em>anything</em>. Because many JavaScript developers do not like and do not want to use classes, the option to write function components was a huge step forward. But outside of developer preferences, React Hooks open up new ways to write code in React apps, and hopefully help you reduce your code footprint in the process.</p>\n<p>Hooks introduced a new way to handle lifecycle events in React as well. Gone are the <code>componentDidMount</code> and <code>componentDidUpdate</code> methods. In is the simple and elegant <code>useEffect</code> function.</p>\n<p>You can read a lot more about the logic behind React's introduction of hooks <a href=\"https://reactjs.org/docs/hooks-intro.html\">here</a>, but for the sake of this tutorial, I think that's enough of an intro.</p>\n<h2>Creating our first Hook</h2>\n<p>A hook is just a function that returns a value. The big gotcha with Hooks, though, is that they can only be called within the body of a function component. Keep that in mind as we progress. It's still relatively early in the life of Hooks, but there are some standards and conventions in place. Convention is to house your custom hooks in a folder called something like <code>hooks</code>. Let's do that.</p>\n<p>Create a folder within the <code>src</code> directory of your project called <code>hooks</code>. Inside that folder, we're going to create a file using another convention within the React Hooks community. Developers will generally name their hooks with a <code>useFunctionPurpose</code> type of pattern. For example, if you were building a Hook that determined whether a navigation bar should show up or not, you might name the Hook file <code>useNavigation</code>. For us, we're going to call our file <code>useMonitoring</code>.</p>\n<p>Create that file inside the <code>hooks</code> directory, and then we can begin building the function. We'e going to go line by line and then I'll show the whole file in one snippet. Let's start by importing the necessary functions from React.</p>\n<p><code>import { useState, useEffect } from 'react';</code></p>\n<p>I briefly touched on <code>useEffect</code>. It can be thought of in the same context as <code>componentDidMount</code> or <code>componentDidUpdate</code>. We'll make use of this to handle some logic in the setup of our Exceptionless client. <code>useState</code> can be thought of like <code>this.state</code> and <code>this.setState</code> in React class components.</p>\n<p>Next, we'll get access to the Exceptionless JavaScript client like this:</p>\n<p><code>import { ExceptionlessClient } from &quot;exceptionless/dist/exceptionless&quot;;</code></p>\n<p>Note: it's important to reference the <code>/dist/exceptionless</code> file because Exceptionless targets multiple environments and we want to make sure to import the right one.</p>\n<p>Next we're going to handle something I mentioned earlier. Exceptionless is a class-based client. This means we have the option of instantiating that class everytime we use it, or we can make use of a singleton provided to us out of the box by Exceptionless. We set up the singleton patter first and then we will use some logic to handle situations where that singleton may not need to be used. Go ahead and grab the <code>default</code> client from Exceptionless like this:</p>\n<p><code>const defaultClient = ExceptionlessClient.default;</code></p>\n<p>If you haven't done so, get yourself an API Key from Exceptionless. You can <a href=\"https://exceptionless.com/\">sign up for a free account here</a>. Once you have that, we're going to provide that key to to the default Exceptionless client. I like to make use of environment variables even when using keys that are safe to expose in the browser. So mine looks like this:</p>\n<p><code>defaultClient.config.apiKey = process.env.REACT_APP_EXCEPTIONLESS_API_KEY;</code></p>\n<p>Now that we've handled all our imports and initial configuration, we can frame out our hook function. The bare bones function looks like this:</p>\n<pre><code class=\"language-javascript\">export const useMonitoring = ({ config, useDefault }) =&gt; {\n  // Code goes here\n}\n</code></pre>\n<p>That's not much to look at, but there are two things I want to call out. The function name follows the convention I mentioned before, and this function takes two props: <code>config</code> and <code>useDefault</code>. If we are making use of the default singleton instance of the Exceptionless client, <code>useDefault</code> would be true and <code>config</code> would be null. However, if we are creating a custom instance of the Exceptionless client, <code>config</code> would be an object and <code>useDefault</code> would be either null or false.</p>\n<p>Let's handle that logic. At the top of your function add the following:</p>\n<p><code>const [client, setClient] = useState(defaultClient);</code></p>\n<p>We are making use of the built-in <code>useState</code> hook here. We are simply defining a <code>client</code> state variable, defining a function that will be used to update that variable (<code>setClient</code>), and setting a defualt value for our variable. As you can see, we set the default value to use the default client from Exceptionless. Makes sense, right?</p>\n<p>Next, we're going to use the built-in <code>useEffect</code> hook to determine what client should be returned for use in the particular part of the app that requested it.</p>\n<pre><code class=\"language-javascript\">useEffect(() =&gt; {\n    if(useDefault) {\n      return client;      \n    } else if(config) {\n      config.apiKey = process.env.REACT_APP_EXCEPTIONLESS_API_KEY;      \n      setClient(new ExceptionlessClient(config));\n    } else {\n      throw &quot;Please pass useDefault as true or a config object in&quot;;\n    }\n  });\n</code></pre>\n<p>In this case, it's best to think of our <code>useEffect</code> function in the same way you think of <code>componentDidUpdate</code>. Any update to the component that called our <code>useMonitoring</code> Hook will trigger another event within our <code>useEffect</code> function.</p>\n<p>If you wanted this <code>useEffect</code> method to operate more like <code>componentDidMount</code>, you would structure it like this:</p>\n<pre><code class=\"language-javascript\">useEffect(() =&gt; {\n\n}, []) // &lt;-- This array says only run this function once when the component mounts\n</code></pre>\n<p>The empty array in the above example can be filled with a list of dependencies. Say, for example, you want your <code>useEffect</code> method to run everytime some specific variable changes, you would just pass that variable name into the array.</p>\n<p>Ok back to our <code>useEffect</code> method. You can see we are checking the <code>useDefault</code> prop I mentioned before. If it is truthy, we return the client state variable. We had already set that variable to use the singleton Exceptionless client, so all we have to do is return it. If <code>useDefault</code> is falsey, we then check for the config object. If it's there, we add the apiKey to whatever values were passed into the config object, and then we instantiate a new Exceptionless client.</p>\n<p>If no <code>config</code> object is provided, we throw an error. You could take this a step further and check if the <code>config</code> prop is actually of type object, but, hey, that's what Typescript is for, right? We're living dangerously in this crazy, crazy dynamically typed world.</p>\n<p>The final thing you need to do in your <code>useMonitoring</code> function is return the client. Just as easy as it sounds:</p>\n<p><code>return client;</code></p>\n<p>Here's the whole, complete file:</p>\n<pre><code class=\"language-javascript\">import { useState, useEffect } from 'react';\nimport { ExceptionlessClient } from &quot;exceptionless/dist/exceptionless&quot;;\nconst defaultClient = ExceptionlessClient.default;\ndefaultClient.config.apiKey = process.env.REACT_APP_EXCEPTIONLESS_API_KEY;\n\nexport const useMonitoring = ({ config, useDefault }) =&gt; {\n  const [client, setClient] = useState(defaultClient);\n  useEffect(() =&gt; {\n    if(useDefault) {\n      return client;      \n    } else if(config) {\n      config.apiKey = process.env.REACT_APP_EXCEPTIONLESS_API_KEY;      \n      setClient(new ExceptionlessClient(config));\n    } else {\n      throw &quot;Please pass useDefault as true or a config object in&quot;;\n    }\n  });\n  return client;\n}\n</code></pre>\n<p>Ready to use this bad boy?</p>\n<h2>Using your custom Hook</h2>\n<p>We created a basic React app, so let's just make use of what comes out of the box. Open your <code>App.js</code> file, and import your new custom Hook.</p>\n<p><code>import { useMonitoring } from &quot;./hooks/useMonitoring&quot;;</code></p>\n<p>You'll also need to import the built-in <code>useEffect</code> Hook from React:</p>\n<p><code>import { useEffect } from 'react';</code></p>\n<p>Now, withing the main <code>App</code> function, you can use your new custom Hook:</p>\n<p><code>const exceptionlessClient = useMonitoring({ useDefault: true });</code></p>\n<p>How can we test this now? Well, let's make use of the <code>useEffect</code> function to throw an error as soon as the component mounts.</p>\n<pre><code class=\"language-javascript\">useEffect(() =&gt; {\n  throwException();\n}, []);\n</code></pre>\n<p>As you remember, the empty array at the end of the function says this should only run once when the component mounts.</p>\n<p>Now, define the actual <code>throwException</code> function like this:</p>\n<pre><code class=\"language-javascript\">const throwException = () =&gt; {\n  try {\n    throw new Error(&quot;Whoops, it broke&quot;); \n  } catch (error) {\n    exceptionlessClient.submitException(error);\n  }\n}\n</code></pre>\n<p>Ready to test this out? If you previously started your React app, it probably already has worked. If you haven't started the app, go ahead and do that now.</p>\n<p>You won't see much beyond the default starter React boiletplate. But that's OK. Open up your Exceptionless dashboard, and you should see an exception has, in fact, been captured.</p>\n<p><img src=\"https://exceptionless.github.io/website/example_react_exception.png\" alt=\"Example exception from React app\"></p>\n<p>If you click into that exception, you'll get a bunch of additional, useful, information. You can start to see how this can be helpful.</p>\n<p>Now is the time where I remind you, our custom Hook can only be used within the body of your component functions. If you were to try to use your Hook in a Redux action function, you'd see an error. The beauty is, even if you're using Redux or something else, you can still throw errors back to your component and handle the error with your <code>useMonitoring</code> hook.</p>\n<p>But Exceptionless is more than just errors. Let's build a quick, more practical example.</p>\n<h2>Usage Tracking</h2>\n<p>In your <code>App.js</code> file, we're going to remove all the boilerplate and add some ugly buttons. No styling in this post. This is what your <code>App.js</code> file should look like now:</p>\n<pre><code class=\"language-javascript\">import { useMonitoring } from &quot;./hooks/useMonitoring&quot;;\n\nfunction App() {\n  const exceptionlessClient = useMonitoring({ useDefault: true });\n\n  const handleButtonClick = (planName) =&gt; {\n    exceptionlessClient.submitFeatureUsage(planName);\n  }\n  return (\n    &lt;div&gt;\n      &lt;button onClick={() =&gt; handleButtonClick(&quot;Free&quot;)}&gt;Free Plan - Learn More&lt;/button&gt;\n      &lt;button onClick={() =&gt; handleButtonClick(&quot;Starter&quot;)}&gt;Starter Plan - Learn More&lt;/button&gt;\n      &lt;button onClick={() =&gt; handleButtonClick(&quot;Premium&quot;)}&gt;Premium Plan - Learn More&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre>\n<p>You can see we have what might be a pricing page in an app. There are three buttons, one for each plan. We have wired up a button that will call a function that ultimately sends a feature usage event to Exceptionless. Go ahead and try clicking the buttons.</p>\n<p>If you go to your Exceptionless dashboard and click the Feature Usage link on the left, you'll see these events have been captured in a dedicated section that makes it easy for you to track, well, feature usage. This may not replace your analytics provider, but it goes a long way.</p>\n<p><img src=\"https://exceptionless.github.io/website/feature_usage_react.png\" alt=\"Feature usage example\"></p>\n<h2>Wrapping up</h2>\n<p>There is a lot more you can do with Exceptionless. For example, you may have noticed, we have only passed in the <code>useDefault</code> prop to our custom Hook. You can completely customize your Exceptionless configuration and pass in a <code>config</code> prop instead. I would encourage you to <a href=\"https://exceptionless.com/docs/clients/javascript/client-configuration/\">read up on the options here</a>.</p>\n<p>Exceptionless <a href=\"https://exceptionless.com/docs/clients/javascript/sending-events/\">provides a lot of methods</a> built into its JavaScript client that will make debugging, logging, and tracking easier.</p>",
      "date_published": "2021-01-19T00:00:00Z"
    },
    {
      "id": "https://exceptionless.github.io/website/news/2020/2020-12-7-why-you-should-be-practicing-exception-driven-development/",
      "url": "https://exceptionless.github.io/website/news/2020/2020-12-7-why-you-should-be-practicing-exception-driven-development/",
      "title": "Why You Should be Practicing Exception Driven Development",
      "content_html": "<p>You've heard of test-driven development. You've heard of behavior-driven development. Maybe you've even heard of acceptance-driven development. But you probably haven't heard much about exception-driven development. Let's take a look at what that type of development process is and why you should be practicing it.</p>\n<h2>Exception Driven Development</h2>\n<p>Jeff Atwood, of <a href=\"https://blog.codinghorror.com/\">Coding Horror</a>, wrote a <a href=\"https://blog.codinghorror.com/exception-driven-development/\">blog post</a> almost 12 years ago about this topic. In those dozen years since his post, the need for exception-driven development has only increased, but developers and companies need a clear understanding of how and why to practice this type of development.</p>\n<p>At a high-level, exception-driven development is simply the practice of monitoring for exceptions in your code and shipping fixes quickly. To ensure you are monitoring the right things and shipping the right fixes, all without burdening your users, you have to make sure you are collecting the right data.</p>\n<p>Contextual data is the key to exception-driven development. Arbitrary data from various points of input may not be useful. Data that is highly contextual to user actions, user experiences, and points in time during the use of your app will allow you to target better solutions and ship faster.</p>\n<p>With your contextual data in hand, you can start to fix issues. But here's the rub: You can't wait until you &quot;have enough&quot; fixed for a deployment. Part of the exception-driven development process is deploying often. Have a single bug that took one line to fix? Cool, ship it. Know that you'll have additional features to put out in a few days and you're considering holding your bug fix for that deployment? Don't. Ship the bug fix, then ship the features.</p>\n<p>Exception-driven development isn't a mysterious new process for most developers, but it is a mindset shift within many organizations. Bug fixes, listening to the data, and responsiveness must take priority if you are to transition to an exception-driven development cycle. While it may not take much effort to change your company's internal process, it may still take some convincing. So, why should you and your company practice exception-driven development?</p>\n<h2>Why Exception Driven Development</h2>\n<p>The first reason you should care is the most obvious reason. Your code has bugs. It does. No matter how good you are, you're going to ship bugs and you need to be ready to fix those bugs. Jeff Atwood probably said it best in his post about exception-driven development:</p>\n<blockquote>\n<p>The question isn't how many bugs you will ship but how fast you can fix them.</p>\n</blockquote>\n<p>Bugs are a part of code. Some never get fixed. But the ones that need to be fixed need to be fixed quickly. The trouble, of course, is that if you are relying on your users to tell you about these bugs, you've already taken too long to fix the issue.</p>\n<p>Wait, what?</p>\n<p>It's true. If your users have told you about bugs through email or Slack or Discord, you have already taken too long to resolve the issue. This is where the heart of exception-driven development comes in. You need to know about issues the second they arise.</p>\n<p>You don't want to turn into this guy, right?</p>\n<p class=\"text-center\"><img src=\"https://exceptionless.github.io/website/tech_support.png\" alt=\"Picture of an angry cat acting as tech support\"></p>\n<p>Think about it this way. How many lines of code does your application have? Got that number in mind? Ok, now divide it by 1000. Take your resulting number and multiply it by 15. <a href=\"https://www.quora.com/What-is-the-average-ratio-of-bugs-to-a-line-of-code\">That is possibly how many bugs</a> you have in your software <em>right now</em>. Knowing this, don't you think it's important to try to find these bugs before your users have to tell you about them?</p>\n<p>By practicing exception-driven development, you make your customers happier which protects your brand image. Do you want to be the brand that has a ton of bugs or do you want to be the brand that solves problems? You also make your developers happier. Would you rather fix a bug on a piece of code shortly after you were working on it, or do you want to try to fix it six months later after you've long forgotten about that code?</p>\n<p>Customer retention, customer conversion, productivity, morale, and more are the reasons exception-driven development is important. Convinced yet? Good, now how do you do it?</p>\n<h2>How to Practice Exception Driven Development</h2>\n<p>If you remember, the first step of exception-driven development is to collect <em>contextual</em> data. Contextual data means data more than the stack trace itself. You should be collecting those traces, but the stack trace is just part of the picture. Some of the questions your contextual data should be answering include:</p>\n<ul>\n<li>What user had this problem?</li>\n<li>Where in the application did the problem occur?</li>\n<li>Has the problem occurred previously?</li>\n<li>What actions did the user take leading up to the issue?</li>\n</ul>\n<p>You can probably think of other questions you'd like answered to help you with the bugs that come in. But notice that the suggestion here is not to collect this information directly from your users. Don't wait for an email from them. Don't follow-up with questions about their operating system and browser. Collect that information upfront without the user having to take action, and you will have your contextual data. Services like <a href=\"https://exceptionless.com/\">Exceptionless</a> make this easy.</p>\n<p>But why use a service like Exceptionless? You're a developer, you can just build the solution yourself. Sure you can, but then you have to manage that solution. You have to fix bugs on that solution while also fixing bugs you've found from your actual production application. You're not in the business of running an error monitoring service. But <a href=\"https://exceptionless.com/\">Exceptionless</a> is.</p>\n<p>Once you've collected your contextual data, you should know what to fix, where to fix it, and why it needs to be fixed. So, the logical thing to do is—well—fix it. The trick, though, is not to allow code creep to slow your release down. It's easy (trust me we all do it) to say, &quot;oh, I'll just add this little feature or change this one other thing&quot; when you're trying to fix a bug. You have to fight that urge, fix the bug, commit the code, and ship it. Then, you can go back and work on the shiny thing that <strong>almost</strong> distracted you.</p>\n<p>Once your code is shipped, if you are using <a href=\"https://exceptionless/\">Exceptionless</a>, you can mark the version that fixed the bug right within your dashboard. By doing this, you'll automatically know if you have any regressions. Exceptionless will track new occurrences of the error and compare the occurrence against the version of software the user is using and the version you marked as solving the problem. If those versions match, it's a regression.</p>\n<h2>Conclusion</h2>\n<p>The whole flow of collecting data, analyzing the data, writing code, and shipping should not be foreign to you. Yet, exception-driven development is still not practiced everywhere. Hopefully, this article helps you understand why you should change your ways and how to do it.</p>",
      "date_published": "2020-12-07T00:00:00Z"
    },
    {
      "id": "https://exceptionless.github.io/website/news/2020/2020-10-29-comparing-monitoring-services/",
      "url": "https://exceptionless.github.io/website/news/2020/2020-10-29-comparing-monitoring-services/",
      "title": "Comparing Monitoring Services",
      "content_html": "<p>Error monitoring is vital to the success of any application. Console logs only get you so far. Once your app is out in the wild, asking your customers to open up the developer tools window and inspect it for errors is a deal-breaker. This is where error monitoring services come in. Let's take a look at three different services:</p>\n<ul>\n<li><a href=\"https://logrocket.com/\">Log Rocket</a></li>\n<li><a href=\"https://sentry.io/\">Sentry</a></li>\n<li><a href=\"https://exceptionless.com/\">Exceptionless</a></li>\n</ul>\n<p>Each service, generally speaking, handles errors and logging for your applications, but not all services are created equally. Let's take a closer look at each and see how they stack up.</p>\n<h1>Log Rocket</h1>\n<p><a href=\"https://logrocket.com/\">Log Rocket</a> was founded in 2015 and is an error monitoring service that focuses on replaying the events that led up to the error. While some services focus on digging into the error details themselves, Log Rocket uses HTML from the user's session to reconstruct a playback of what the user experienced.</p>\n<blockquote>\n<p>What LogRocket does is we capture a recording in real time of all the user activity so the developer on the other end can replay exactly what went wrong and troubleshoot issues faster.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://techcrunch.com/2019/03/21/logrocked-nabs-11m-series-a-to-fix-web-application-errors-faster/?guccounter=1&amp;guce_referrer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8&amp;guce_referrer_sig=AQAAAIPY3DnugxcKUD8lyUXLl-FXSS29_pkxK32gWJb_Kp0lGk2YWj19tXm2PCHIjj4kFV6DBtRurKKebhBH5czcymF2Ct0k_D1UFvoJtxkD-76DSFmTqD07uaoxVS69YzFZLa-QsEcsoiwVbHWBFkLyRywxOBu8baLFu34hztJrZSCa\">Matthew Arbesfeld, co-founder of Log Rocket</a></li>\n</ul>\n<p><img src=\"https://exceptionless.github.io/website/log_rocket.png\" alt=\"Log Rocket example\"></p>\n<p>Log Rocket is a venture-backed company that has raised $30 million in its history. It provides its tools exclusively as a for-profit, hosted solution. They do offer self-hosted options, but only as part of their enterprise, custom pricing.</p>\n<p>Their focus is on user experience through the tracking of everything a user does on the site. While this is helpful, it is also a bit invasive in the fact that the default installation of Log Rocket captures just about everything a user does in the application.</p>\n<h1>Sentry</h1>\n<p><a href=\"https://sentry.io/\">Sentry</a> was founded in 2012 and is focused on capturing errors at the code-level and sending them to a repository for review and organization. Sentry allows you to configure the groupings of errors and presents them in an interface designed to surface the most-pressing errors first.</p>\n<p>In addition to surfacing errors, Sentry allows users to create custom alerts. For example, should a specific event occur, you can set up a trigger to send an email to your team. This is generally used for errors, but it could be used for just about any event sent through to Sentry.</p>\n<p><img src=\"https://exceptionless.github.io/website/sentry.png\" alt=\"Sentry Example\"></p>\n<p>Sentry, like Log Rocket, is also a venture-backed company. They have raised over $66 million in their history. Unlike Log Rocket, Sentry provides an open-source and self-hosted solution for free. For users that do not want to pay for Sentry's hosted option, they can utilize Docker to run a self-hosted, containerized version of the Sentry platform.</p>\n<p>One big differentiator for Sentry is its focus on providing services for a wide array of platforms.</p>\n<blockquote>\n<p>Sentry differentiates from legacy application performance monitoring solutions by focusing on software that runs on devices its developers have no control over, including mobile and IoT devices and smart sensor networks.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://techcrunch.com/2019/09/24/sentry-raises-40-million-series-c-led-by-accel-for-its-error-tracking-software/\">Techcrunch, 2019</a></li>\n</ul>\n<h1>Exceptionless</h1>\n<p><a href=\"https://exceptionless.com/\">Exceptionless</a> has been around the longest of the three services reviewed here. Created as a software offering from the parent company <a href=\"https://www.codesmithtools.com/\">CodeSmith Tools</a>, Exceptionless was established in 2010 and is privately held. It is positioned as a tool to help first and a product second. This is why one of Exceptionless's main focuses is the open-source community.</p>\n<p>Exceptionless lets developers capture logs, events, and errors. However, Exceptionless's real differentiator is its real-time delivery mechanisms. Rather than costly code deployments to change your error monitoring configurations, Exceptionless allows you to make changes from their user interface and those changes will apply instantly in your application. This is key when it becomes clear that additional errors need to be surfaced quickly.</p>\n<p>From the user experience and customer experience front, Exceptionless works hard to stand out from the competition. In Exceptionless 7.0, customers are now able to mark stacks of errors and logs as &quot;discarded&quot;, the events will no longer count against plan quotas. Combine that with their chat, email, and Discord support, and Exceptionless proves its focus on customers.</p>\n<p>Digging into the product features, Exceptionless provides one of the cleanest views for understanding events and errors in your application.</p>\n<p><img src=\"https://exceptionless.github.io/website/assets/img/event-occurrence-1024x791.jpg\" alt=\"Example error details\"></p>\n<p>All the information you need about errors and events are captured in a simple, easy to read view. From your dashboard, you can consolidate events into stacks to help group relevant issues. You can also indicate the resolution of events based not just on the fact that the issue was resolve but based on the version of your software that fixed the event. Exceptionless will automatically recognize any new errors that come in with an older version and group them in the resolved bucket. However, should the error surface on the version of your software in which you marked the issue fixed, Exceptionless will classify this event as a regression without you having to manually do so.</p>\n<h1>So Which One is Right For You?</h1>\n<p>The answer to this often comes down to what's most important for your application. Each service has its merits, but the value provided differs based on use-cases. Log Rocket offers full session replays, but may not be the right solution for digging deep into stack traces. Sentry offers full stack trace reviews and error categorization, but it may not be the right solution if you need the ability to update your error handling configuration in real-time. Exceptionless provides real-time error monitoring and configuration, and it is committed to the open-source community.</p>\n<p>In the end, the choice is yours.</p>",
      "date_published": "2020-10-29T00:00:00Z"
    }
  ]
}